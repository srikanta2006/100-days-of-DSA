[I]
Question number: 90
Title: subsets II
description: 
Given an integer array nums that may contain duplicates, return all possible subsets (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

Intuition:
just like the problem in subsets we need to use backtracking in two steps include and exclude.
but we should not return the same subset twice. for that track the recursion tree.
Approach:
1)same logic until include, but the logic changes for exclude. 
2)for selecting the next index its not i+1;
3)go for the index which in which the number is different.
4)for that run a loop to find the index
5)before that sort the array

Complexity:
Time complexity:
O(2^n)

Space complexity:
O(n)

Code:
class Solution {
public:
    void allsubsets(vector<int>& nums, vector<int>& arr, vector<vector<int>>& ans, int i){
        if(i==nums.size()){
            ans.push_back(arr);
            return;
        }

        //include
        arr.push_back(nums[i]);
        allsubsets(nums, arr, ans, i+1);

        arr.pop_back();

        //exclude
        int idx=i+1;
        while(idx<nums.size() && nums[idx]==nums[idx-1]){
            idx++;
        }
        allsubsets(nums, arr, ans, idx);

    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<int> arr;
        vector<vector<int>> ans;
        allsubsets(nums, arr, ans, 0);
        return ans;
    }
};